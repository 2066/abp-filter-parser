{"version":3,"sources":["../abp-filter-parser.js"],"names":[],"mappings":"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","file":"abp-filter-parser.jsm","sourcesContent":["/*\nvar filterOptions = new Set([\n  // Include or exclude JavaScript files.\n  'script',\n  // Include or exclude image files.\n  'image',\n  // Include or exclude stylesheets (CSS files).\n  'stylesheet',\n  // Include or exclude content handled by browser plugins like Flash\n  // or Java.\n  'object',\n  // Include or exclude files loaded by browser plugins.\n  'object-subrequest',\n  // Include or exclude pages loaded within pages (frames).\n  'subdocument',\n  // Used to whitelist the page itself (e.g. @@||example.com^$document).\n  'document',\n  // Used to prevent element rules from applying on a page\n  // (e.g. @@||example.com^$elemhide).\n  'elemhide',\n  // Specify a list of domains, separated by bar lines (|), on which a\n  // filter should be active. A filter may be prevented from being activated\n  // on a domain by preceding the domain name with a tilde (~).\n  'domain=',\n  // Specify whether a filter should be active on third-party or first domains.\n  'third-party',\n]);\n*/\n\nconst separatorCharacters = ':?/=^';\n\n/**\n * Parses the domain string using the passed in separator and\n * fills in options.\n */\nexport function parseDomains(input, separator, options) {\n  options.domains = options.domains || [];\n  options.skipDomains = options.skipDomains || [];\n  let domains = input.split(separator);\n  options.domains = options.domains.concat(domains.filter((domain) => domain[0] !== '~'));\n  options.skipDomains = options.skipDomains.concat(domains\n    .filter((domain) => domain[0] === '~')\n    .map((domain) => domain.substring(1)));\n}\n\n/**\n * Parses options from the passed in input string\n */\nexport function parseOptions(input) {\n  let output = {\n    binaryOptions: new Set(),\n  };\n  input.split(',').forEach((option) => {\n    option = option.trim();\n    if (option.startsWith('domain=')) {\n      let domainString = option.split('=')[1].trim();\n      parseDomains(domainString, '|', output);\n    } else {\n      output.binaryOptions.add(option);\n    }\n  });\n  return output;\n}\n\nfunction findFirstSeparatorChar(input, startPos) {\n  for (let i = startPos; i < input.length; i++) {\n    if (separatorCharacters.indexOf(input[i]) !== -1) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Parses an HTML filter and modifies the passed in parsedFilterData\n * as necessary.\n *\n * @param input: The entire input string to consider\n * @param index: Index of the first hash\n * @param parsedFilterData: The parsedFilterData object to fill\n */\nexport function parseHTMLFilter(input, index, parsedFilterData) {\n  let domainsStr = input.substring(0, index);\n  parsedFilterData.options = {};\n  if (domainsStr.length > 0) {\n    parseDomains(domainsStr, ',', parsedFilterData.options)\n  }\n\n  // The XOR parsedFilterData.elementHidingException is in case the rule already\n  // was specified as exception handling with a prefixed @@\n  parsedFilterData.isException = !!(input[index + 1] === '@' ^\n    parsedFilterData.isException);\n  if (input[index + 1] === '@') {\n    // Skip passed the first # since @# is 2 chars same as ##\n    index++;\n  }\n  parsedFilterData.htmlRuleSelector = input.substring(index + 2);\n}\n\nexport function parseFilter(input, parsedFilterData) {\n  input = input.trim();\n\n  // Check for comment or nothing\n  if (input.length === 0) {\n    return false;\n  }\n\n  // Check for comments\n  let beginIndex = 0;\n  if (input[beginIndex] === '[' || input[beginIndex] === '!') {\n    parsedFilterData.isComment = true;\n    return false;\n  }\n\n  // Check for exception instead of filter\n  parsedFilterData.isException = input[beginIndex] === '@' &&\n    input[beginIndex + 1] === '@';\n  if (parsedFilterData.isException) {\n    beginIndex = 2;\n  }\n\n  // Check for element hiding rules\n  let index = input.indexOf('#', beginIndex);\n  if (index !== -1) {\n    if (input[index + 1] === '#' || input[index + 1] === '@') {\n      parseHTMLFilter(input.substring(beginIndex), index - beginIndex, parsedFilterData);\n      // HTML rules cannot be combined with other parsing,\n      // other than @@ exception marking.\n      return true;\n    }\n  }\n\n  // Check for options, regex can have options too so check this before regex\n  index = input.indexOf('$', beginIndex);\n  if (index !== -1) {\n    parsedFilterData.options = parseOptions(input.substring(index + 1));\n    // Get rid of the trailing options for the rest of the parsing\n    input = input.substring(0, index);\n  } else {\n    parsedFilterData.options = {};\n  }\n\n  // Check for a regex\n  parsedFilterData.isRegex = input[beginIndex] === '/' &&\n    input[input.length - 1] === '/' && beginIndex !== input.length - 1;\n  if (parsedFilterData.isRegex) {\n    parsedFilterData.data = input.slice(beginIndex + 1, -1);\n    return true;\n  }\n\n  // Check if there's some kind of anchoring\n  if (input[beginIndex] === '|') {\n    // Check for an anchored domain name\n    if (input[beginIndex + 1] === '|') {\n      parsedFilterData.hostAnchored = true;\n      let indexOfSep = findFirstSeparatorChar(input, beginIndex + 1);\n      if (indexOfSep === -1) {\n        indexOfSep = input.length;\n      }\n      beginIndex += 2;\n      parsedFilterData.host = input.substring(beginIndex, indexOfSep);\n    } else {\n      parsedFilterData.leftAnchored = true;\n      beginIndex++;\n    }\n  }\n  if (input[input.length - 1] === '|') {\n    parsedFilterData.rightAnchored = true;\n    input = input.substring(0, input.length - 1);\n  }\n\n  parsedFilterData.data = input.substring(beginIndex) || '*';\n  return true;\n}\n\nexport function parse(input, parserData) {\n  parserData.filters = parserData.filters || [];\n  parserData.exceptionFilters = parserData.exceptionFilters  || [];\n  parserData.htmlRuleFilters = parserData.htmlRuleFilters || [];\n  let startPos = 0;\n  let endPos = input.length;\n  let newline = '\\n';\n  while (startPos <= input.length) {\n    endPos = input.indexOf(newline, startPos);\n    if (endPos === -1) {\n      newline = '\\r';\n      endPos = input.indexOf(newline, startPos);\n    }\n    if (endPos === -1) {\n      endPos = input.length;\n    }\n    let filter = input.substring(startPos, endPos);\n    let parsedFilterData = {};\n    if (parseFilter(filter, parsedFilterData)) {\n      if (parsedFilterData.htmlRuleSelector) {\n        parserData.htmlRuleFilters.push(parsedFilterData);\n      } else if (parsedFilterData.isException) {\n        parserData.exceptionFilters.push(parsedFilterData);\n      } else {\n        parserData.filters.push(parsedFilterData);\n      }\n    }\n    startPos = endPos + 1;\n  }\n  return parserData;\n}\n\nfunction getDomainIndex(input) {\n  let index = input.indexOf(':');\n  ++index;\n  while (input[index] === '/') {\n    index++;\n  }\n  return index;\n}\n\n// Similar to str1.indexOf(filter, startingPos) but with\n// extra consideration to some ABP filter rules like ^\nfunction indexOfFilter(input, filter, startingPos) {\n  if (filter.length > input.length) {\n    return -1;\n  }\n\n  let filterParts = filter.split('^');\n  let index = startingPos;\n  let beginIndex = -1;\n  let prefixedSeparatorChar = false;\n\n  for (let f = 0; f < filterParts.length; f++) {\n    if (filterParts[f] === '') {\n      prefixedSeparatorChar = true;\n      continue;\n    }\n\n    index = input.indexOf(filterParts[f], index);\n    if (index === -1) {\n      return -1;\n    }\n    if (beginIndex === -1) {\n      beginIndex = index;\n    }\n\n    if (prefixedSeparatorChar) {\n      if (separatorCharacters.indexOf(input[index - 1]) === -1) {\n        return -1;\n      }\n    }\n    // If we are in an in between filterPart\n    if (f + 1 < filterParts.length &&\n        // and we have some chars left in the input past the last filter match\n        input.length > index + filterParts[f].length) {\n      if (separatorCharacters.indexOf(input[index + filterParts[f].length]) === -1) {\n        return -1;\n      }\n\n    }\n\n    prefixedSeparatorChar = false;\n  }\n  return beginIndex;\n}\n\nfunction getUrlHost(input) {\n  let domainIndexStart = getDomainIndex(input);\n  let domainIndexEnd = findFirstSeparatorChar(input, domainIndexStart);\n  if (domainIndexEnd === -1) {\n    domainIndexEnd = input.length;\n  }\n  return input.substring(domainIndexStart, domainIndexEnd);\n}\n\nfunction filterDataContainsOption(parsedFilterData, option) {\n  return parsedFilterData.options &&\n    parsedFilterData.options.binaryOptions &&\n    parsedFilterData.options.binaryOptions.has(option);\n}\n\nfunction isThirdPartyHost(baseContextHost, testHost) {\n  if (!testHost.endsWith(baseContextHost)) {\n    return true;\n  }\n\n  let prefix = testHost.slice(0, -baseContextHost.length);\n  if (prefix.length > 0 && !prefix.endsWith('.')) {\n    return true;\n  }\n\n  return false;\n}\n\n// Determines if there's a match based on the options, this doesn't\n// mean that the filter rule shoudl be accepted, just that the filter rule\n// should be considered given the current context.\n// By specifying context params, you can filter out the number of rules which are\n// considered.\nfunction matchOptions(parsedFilterData, input, contextParams = {}) {\n  // Lazilly fill this out to be more efficient\n  // Element type checks\n  let elementTypeParams = ['script', 'image', 'stylesheet', 'object',\n   'xmlhttprequest', 'object-subrequest', 'subdocument', 'document', 'other'];\n  for (let elementType of elementTypeParams) {\n    // Check for script context\n    if (contextParams[elementType] !== undefined) {\n      if (!contextParams[elementType] && filterDataContainsOption(parsedFilterData, elementType)) {\n        return false;\n      }\n      else if (contextParams[elementType] && filterDataContainsOption(parsedFilterData, '~' + elementType)) {\n        return false;\n      }\n    }\n  }\n\n  // Domain option check\n  if (contextParams.domain !== undefined && parsedFilterData.options) {\n    if (parsedFilterData.options.domains || parsedFilterData.options.skipDomains) {\n      // Get the domains that should be considered\n      let shouldBlockDomains = parsedFilterData.options.domains.filter((domain) =>\n        !isThirdPartyHost(domain, contextParams.domain));\n\n      let shouldSkipDomains = parsedFilterData.options.skipDomains.filter((domain) =>\n        !isThirdPartyHost(domain, contextParams.domain));\n      // Handle cases like: example.com|~foo.example.com should llow for foo.example.com\n      // But ~example.com|foo.example.com should block for foo.example.com\n      let leftOverBlocking = shouldBlockDomains.filter((shouldBlockDomain) =>\n        shouldSkipDomains.every((shouldSkipDomain) =>\n          isThirdPartyHost(shouldBlockDomain, shouldSkipDomain)));\n      let leftOverSkipping = shouldSkipDomains.filter((shouldSkipDomain) =>\n        shouldBlockDomains.every((shouldBlockDomain) =>\n          isThirdPartyHost(shouldSkipDomain, shouldBlockDomain)));\n\n      // If we have none left over, then we shouldn't consider this a match\n      if (shouldBlockDomains.length === 0 && parsedFilterData.options.domains.length !== 0 ||\n          shouldBlockDomains.length > 0 && leftOverBlocking.length === 0 ||\n          shouldSkipDomains.length > 0 && leftOverSkipping.length > 0) {\n        return false;\n      }\n    }\n  }\n\n  // If we're in the context of third-party site, then consider third-party option checks\n  if (contextParams['third-party'] !== undefined) {\n    // Is the current rule check for third party only?\n    if (filterDataContainsOption(parsedFilterData, 'third-party')) {\n      let inputHost = getUrlHost(input);\n      let inputHostIsThirdParty = isThirdPartyHost(parsedFilterData.host, inputHost);\n      if (inputHostIsThirdParty || !contextParams['third-party']) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nexport function matchesFilter(parsedFilterData, input, contextParams = {}) {\n  if (!matchOptions(parsedFilterData, input, contextParams)) {\n    return false;\n  }\n\n  // Check for a regex match\n  if (parsedFilterData.isRegex) {\n    if (!parsedFilterData.regex) {\n      parsedFilterData.regex = new RegExp(parsedFilterData.data);\n    }\n    return parsedFilterData.regex.test(input);\n  }\n\n  // Check for both left and right anchored\n  if (parsedFilterData.leftAnchored && parsedFilterData.rightAnchored) {\n    return parsedFilterData.data === input;\n  }\n\n  // Check for right anchored\n  if (parsedFilterData.rightAnchored) {\n    return input.slice(-parsedFilterData.data.length) === parsedFilterData.data;\n  }\n\n  // Check for left anchored\n  if (parsedFilterData.leftAnchored) {\n    return input.substring(0, parsedFilterData.data.length) === parsedFilterData.data;\n  }\n\n  // Check for domain name anchored\n  if (parsedFilterData.hostAnchored) {\n    let inputHost = getUrlHost(input);\n    let matchIndex = inputHost.lastIndexOf(parsedFilterData.host);\n    return (matchIndex === 0 || inputHost[matchIndex - 1] === '.') &&\n      inputHost.length <= matchIndex + parsedFilterData.host.length &&\n      indexOfFilter(input, parsedFilterData.data) !== -1;\n  }\n\n  // Wildcard match comparison\n  let parts = parsedFilterData.data.split('*');\n  let index = 0;\n  for (let part of parts) {\n    let newIndex = indexOfFilter(input, part, index);\n    if (newIndex === -1) {\n      return false;\n    }\n    index = newIndex + part.length;\n  }\n\n  return true;\n}\n\nexport function matches(parserData, input, contextParams = {}) {\n  if (parserData.exceptionFilters.some((parsedFilterData) =>\n      matchesFilter(parsedFilterData, input, contextParams))) {\n    return false;\n  }\n\n  return parserData.filters.some((parsedFilterData) =>\n    matchesFilter(parsedFilterData, input, contextParams));\n}\n"]}