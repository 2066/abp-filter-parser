{"version":3,"sources":["../abp-filter-parser.js"],"names":[],"mappings":"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","file":"abp-filter-parser.jsm","sourcesContent":["/**\n * bitwise mask of different request types\n */\nexport const elementTypes = {\n  SCRIPT: 0o1,\n  IMAGE: 0o2,\n  STYLESHEET: 0o4,\n  OBJECT: 0o10,\n  XMLHTTPREQUEST: 0o20,\n  OBJECTSUBREQUEST: 0o40,\n  SUBDOCUMENT: 0o100,\n  DOCUMENT: 0o200,\n  OTHER: 0o400,\n};\n\n/**\n * Maps element types to type mask.\n */\nexport const elementTypeMaskMap = new Map([\n  ['script', elementTypes.SCRIPT],\n  ['image', elementTypes.IMAGE],\n  ['stylesheet', elementTypes.STYLESHEET],\n  ['object', elementTypes.OBJECT],\n  ['xmlhttprequest', elementTypes.XMLHTTPREQUEST],\n  ['object-subrequest', elementTypes.OBJECTSUBREQUEST],\n  ['subdocument', elementTypes.SUBDOCUMENT],\n  ['document', elementTypes.DOCUMENT],\n  ['other', elementTypes.OTHER]\n]);\n\nconst separatorCharacters = ':?/=^';\n\n/**\n * Parses the domain string using the passed in separator and\n * fills in options.\n */\nexport function parseDomains(input, separator, options) {\n  options.domains = options.domains || [];\n  options.skipDomains = options.skipDomains || [];\n  let domains = input.split(separator);\n  options.domains = options.domains.concat(domains.filter((domain) => domain[0] !== '~'));\n  options.skipDomains = options.skipDomains.concat(domains\n    .filter((domain) => domain[0] === '~')\n    .map((domain) => domain.substring(1)));\n}\n\n/**\n * Parses options from the passed in input string\n */\nexport function parseOptions(input) {\n  let output = {\n    binaryOptions: new Set(),\n  };\n  input.split(',').forEach((option) => {\n    option = option.trim();\n    if (option.startsWith('domain=')) {\n      let domainString = option.split('=')[1].trim();\n      parseDomains(domainString, '|', output);\n    } else {\n      let optionWithoutPrefix = option[0] === '~' ? option.substring(1) : option;\n      if (elementTypeMaskMap.has(optionWithoutPrefix)) {\n        if (option[0] === '~') {\n          output.skipElementTypeMask |= elementTypeMaskMap.get(optionWithoutPrefix);\n        } else {\n          output.elementTypeMask |= elementTypeMaskMap.get(optionWithoutPrefix);\n        }\n      }\n      output.binaryOptions.add(option);\n    }\n  });\n  return output;\n}\n\n/**\n * Finds the first separator character in the input string\n */\nfunction findFirstSeparatorChar(input, startPos) {\n  for (let i = startPos; i < input.length; i++) {\n    if (separatorCharacters.indexOf(input[i]) !== -1) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Parses an HTML filter and modifies the passed in parsedFilterData\n * as necessary.\n *\n * @param input: The entire input string to consider\n * @param index: Index of the first hash\n * @param parsedFilterData: The parsedFilterData object to fill\n */\nexport function parseHTMLFilter(input, index, parsedFilterData) {\n  let domainsStr = input.substring(0, index);\n  parsedFilterData.options = {};\n  if (domainsStr.length > 0) {\n    parseDomains(domainsStr, ',', parsedFilterData.options);\n  }\n\n  // The XOR parsedFilterData.elementHidingException is in case the rule already\n  // was specified as exception handling with a prefixed @@\n  parsedFilterData.isException = !!(input[index + 1] === '@' ^\n    parsedFilterData.isException);\n  if (input[index + 1] === '@') {\n    // Skip passed the first # since @# is 2 chars same as ##\n    index++;\n  }\n  parsedFilterData.htmlRuleSelector = input.substring(index + 2);\n}\n\nexport function parseFilter(input, parsedFilterData) {\n  input = input.trim();\n\n  // Check for comment or nothing\n  if (input.length === 0) {\n    return false;\n  }\n\n  // Check for comments\n  let beginIndex = 0;\n  if (input[beginIndex] === '[' || input[beginIndex] === '!') {\n    parsedFilterData.isComment = true;\n    return false;\n  }\n\n  // Check for exception instead of filter\n  parsedFilterData.isException = input[beginIndex] === '@' &&\n    input[beginIndex + 1] === '@';\n  if (parsedFilterData.isException) {\n    beginIndex = 2;\n  }\n\n  // Check for element hiding rules\n  let index = input.indexOf('#', beginIndex);\n  if (index !== -1) {\n    if (input[index + 1] === '#' || input[index + 1] === '@') {\n      parseHTMLFilter(input.substring(beginIndex), index - beginIndex, parsedFilterData);\n      // HTML rules cannot be combined with other parsing,\n      // other than @@ exception marking.\n      return true;\n    }\n  }\n\n  // Check for options, regex can have options too so check this before regex\n  index = input.indexOf('$', beginIndex);\n  if (index !== -1) {\n    parsedFilterData.options = parseOptions(input.substring(index + 1));\n    // Get rid of the trailing options for the rest of the parsing\n    input = input.substring(0, index);\n  } else {\n    parsedFilterData.options = {};\n  }\n\n  // Check for a regex\n  parsedFilterData.isRegex = input[beginIndex] === '/' &&\n    input[input.length - 1] === '/' && beginIndex !== input.length - 1;\n  if (parsedFilterData.isRegex) {\n    parsedFilterData.data = input.slice(beginIndex + 1, -1);\n    return true;\n  }\n\n  // Check if there's some kind of anchoring\n  if (input[beginIndex] === '|') {\n    // Check for an anchored domain name\n    if (input[beginIndex + 1] === '|') {\n      parsedFilterData.hostAnchored = true;\n      let indexOfSep = findFirstSeparatorChar(input, beginIndex + 1);\n      if (indexOfSep === -1) {\n        indexOfSep = input.length;\n      }\n      beginIndex += 2;\n      parsedFilterData.host = input.substring(beginIndex, indexOfSep);\n    } else {\n      parsedFilterData.leftAnchored = true;\n      beginIndex++;\n    }\n  }\n  if (input[input.length - 1] === '|') {\n    parsedFilterData.rightAnchored = true;\n    input = input.substring(0, input.length - 1);\n  }\n\n  parsedFilterData.data = input.substring(beginIndex) || '*';\n  return true;\n}\n\n/**\n * Parses the set of filter rules and fills in parserData\n * @param input filter rules\n * @param parserData out parameter which will be filled\n *   with the filters, exceptionFilters and htmlRuleFilters.\n */\nexport function parse(input, parserData) {\n  parserData.filters = parserData.filters || [];\n  parserData.exceptionFilters = parserData.exceptionFilters || [];\n  parserData.htmlRuleFilters = parserData.htmlRuleFilters || [];\n  let startPos = 0;\n  let endPos = input.length;\n  let newline = '\\n';\n  while (startPos <= input.length) {\n    endPos = input.indexOf(newline, startPos);\n    if (endPos === -1) {\n      newline = '\\r';\n      endPos = input.indexOf(newline, startPos);\n    }\n    if (endPos === -1) {\n      endPos = input.length;\n    }\n    let filter = input.substring(startPos, endPos);\n    let parsedFilterData = {};\n    if (parseFilter(filter, parsedFilterData)) {\n      if (parsedFilterData.htmlRuleSelector) {\n        parserData.htmlRuleFilters.push(parsedFilterData);\n      } else if (parsedFilterData.isException) {\n        parserData.exceptionFilters.push(parsedFilterData);\n      } else {\n        parserData.filters.push(parsedFilterData);\n      }\n    }\n    startPos = endPos + 1;\n  }\n}\n\n/**\n * Obtains the domain index of the input filter line\n */\nfunction getDomainIndex(input) {\n  let index = input.indexOf(':');\n  ++index;\n  while (input[index] === '/') {\n    index++;\n  }\n  return index;\n}\n\n/**\n * Similar to str1.indexOf(filter, startingPos) but with\n * extra consideration to some ABP filter rules like ^.\n */\nfunction indexOfFilter(input, filter, startingPos) {\n  if (filter.length > input.length) {\n    return -1;\n  }\n\n  let filterParts = filter.split('^');\n  let index = startingPos;\n  let beginIndex = -1;\n  let prefixedSeparatorChar = false;\n\n  for (let f = 0; f < filterParts.length; f++) {\n    if (filterParts[f] === '') {\n      prefixedSeparatorChar = true;\n      continue;\n    }\n\n    index = input.indexOf(filterParts[f], index);\n    if (index === -1) {\n      return -1;\n    }\n    if (beginIndex === -1) {\n      beginIndex = index;\n    }\n\n    if (prefixedSeparatorChar) {\n      if (separatorCharacters.indexOf(input[index - 1]) === -1) {\n        return -1;\n      }\n    }\n    // If we are in an in between filterPart\n    if (f + 1 < filterParts.length &&\n        // and we have some chars left in the input past the last filter match\n        input.length > index + filterParts[f].length) {\n      if (separatorCharacters.indexOf(input[index + filterParts[f].length]) === -1) {\n        return -1;\n      }\n\n    }\n\n    prefixedSeparatorChar = false;\n  }\n  return beginIndex;\n}\n\nfunction getUrlHost(input) {\n  let domainIndexStart = getDomainIndex(input);\n  let domainIndexEnd = findFirstSeparatorChar(input, domainIndexStart);\n  if (domainIndexEnd === -1) {\n    domainIndexEnd = input.length;\n  }\n  return input.substring(domainIndexStart, domainIndexEnd);\n}\n\nfunction filterDataContainsOption(parsedFilterData, option) {\n  return parsedFilterData.options &&\n    parsedFilterData.options.binaryOptions &&\n    parsedFilterData.options.binaryOptions.has(option);\n}\n\nfunction isThirdPartyHost(baseContextHost, testHost) {\n  if (!testHost.endsWith(baseContextHost)) {\n    return true;\n  }\n\n  let c = testHost[testHost.length - baseContextHost.length - 1];\n  return c !== '.' && c !== undefined;\n}\n\n// Determines if there's a match based on the options, this doesn't\n// mean that the filter rule shoudl be accepted, just that the filter rule\n// should be considered given the current context.\n// By specifying context params, you can filter out the number of rules which are\n// considered.\nfunction matchOptions(parsedFilterData, input, contextParams = {}) {\n  if (contextParams.elementTypeMask !== undefined && parsedFilterData.options) {\n    if (parsedFilterData.options.elementTypeMask !== undefined &&\n        !(parsedFilterData.options.elementTypeMask & contextParams.elementTypeMask)) {\n      return false;\n    } if (parsedFilterData.options.skipElementTypeMask !== undefined &&\n          parsedFilterData.options.skipElementTypeMask & contextParams.elementTypeMask) {\n      return false;\n    }\n  }\n\n  // Domain option check\n  if (contextParams.domain !== undefined && parsedFilterData.options) {\n    if (parsedFilterData.options.domains || parsedFilterData.options.skipDomains) {\n      // Get the domains that should be considered\n      let shouldBlockDomains = parsedFilterData.options.domains.filter((domain) =>\n        !isThirdPartyHost(domain, contextParams.domain));\n\n      let shouldSkipDomains = parsedFilterData.options.skipDomains.filter((domain) =>\n        !isThirdPartyHost(domain, contextParams.domain));\n      // Handle cases like: example.com|~foo.example.com should llow for foo.example.com\n      // But ~example.com|foo.example.com should block for foo.example.com\n      let leftOverBlocking = shouldBlockDomains.filter((shouldBlockDomain) =>\n        shouldSkipDomains.every((shouldSkipDomain) =>\n          isThirdPartyHost(shouldBlockDomain, shouldSkipDomain)));\n      let leftOverSkipping = shouldSkipDomains.filter((shouldSkipDomain) =>\n        shouldBlockDomains.every((shouldBlockDomain) =>\n          isThirdPartyHost(shouldSkipDomain, shouldBlockDomain)));\n\n      // If we have none left over, then we shouldn't consider this a match\n      if (shouldBlockDomains.length === 0 && parsedFilterData.options.domains.length !== 0 ||\n          shouldBlockDomains.length > 0 && leftOverBlocking.length === 0 ||\n          shouldSkipDomains.length > 0 && leftOverSkipping.length > 0) {\n        return false;\n      }\n    }\n  }\n\n  // If we're in the context of third-party site, then consider third-party option checks\n  if (contextParams['third-party'] !== undefined) {\n    // Is the current rule check for third party only?\n    if (filterDataContainsOption(parsedFilterData, 'third-party')) {\n      let inputHost = getUrlHost(input);\n      let inputHostIsThirdParty = isThirdPartyHost(parsedFilterData.host, inputHost);\n      if (inputHostIsThirdParty || !contextParams['third-party']) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Given an individual parsed filter data determines if the input url should block.\n */\nexport function matchesFilter(parsedFilterData, input, contextParams = {}, cachedInputData = {}) {\n  if (!matchOptions(parsedFilterData, input, contextParams)) {\n    return false;\n  }\n\n  // Check for a regex match\n  if (parsedFilterData.isRegex) {\n    if (!parsedFilterData.regex) {\n      parsedFilterData.regex = new RegExp(parsedFilterData.data);\n    }\n    return parsedFilterData.regex.test(input);\n  }\n\n  // Check for both left and right anchored\n  if (parsedFilterData.leftAnchored && parsedFilterData.rightAnchored) {\n    return parsedFilterData.data === input;\n  }\n\n  // Check for right anchored\n  if (parsedFilterData.rightAnchored) {\n    return input.slice(-parsedFilterData.data.length) === parsedFilterData.data;\n  }\n\n  // Check for left anchored\n  if (parsedFilterData.leftAnchored) {\n    return input.substring(0, parsedFilterData.data.length) === parsedFilterData.data;\n  }\n\n  // Check for domain name anchored\n  if (parsedFilterData.hostAnchored) {\n    if (!cachedInputData.currentHost) {\n      cachedInputData.currentHost = getUrlHost(input);\n    }\n\n    return !isThirdPartyHost(parsedFilterData.host, cachedInputData.currentHost) &&\n      indexOfFilter(input, parsedFilterData.data) !== -1;\n  }\n\n  // Wildcard match comparison\n  let parts = parsedFilterData.data.split('*');\n  let index = 0;\n  for (let part of parts) {\n    let newIndex = indexOfFilter(input, part, index);\n    if (newIndex === -1) {\n      return false;\n    }\n    index = newIndex + part.length;\n  }\n\n  return true;\n}\n\nconst maxCached = 100;\n\n/**\n * Using the parserData rules will try to see if the input URL should be blocked or not\n * @param parserData The filter data obtained from a call to parse\n * @param input The input URL\n * @return true if the URL should be blocked\n */\nexport function matches(parserData, input, contextParams = {}, cachedInputData = { }) {\n  delete cachedInputData.currentHost;\n  cachedInputData.misses = cachedInputData.misses || new Set();\n  cachedInputData.missList = cachedInputData.missList || [];\n  if (cachedInputData.missList.length > maxCached) {\n    cachedInputData.misses.delete(cachedInputData.missList[0]);\n    cachedInputData.missList = cachedInputData.missList.splice(1);\n  }\n  if (cachedInputData.misses.has(input)) {\n    return false;\n  }\n\n  if (parserData.filters.some((parsedFilterData) =>\n    matchesFilter(parsedFilterData, input, contextParams, cachedInputData))) {\n    // Check for exceptions only when there's a match because matches are\n    // rare compared to the volume of checks\n    return !parserData.exceptionFilters.some((parsedFilterData) =>\n      matchesFilter(parsedFilterData, input, contextParams, cachedInputData));\n  }\n\n  cachedInputData.missList.push(input);\n  cachedInputData.misses.add(input);\n  return false;\n}\n"]}