{"version":3,"sources":["../abp-filter-parser.js"],"names":[],"mappings":"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","file":"abp-filter-parser.js","sourcesContent":["let BloomFilter = require('bloom-filter-js');\n\n/**\n * bitwise mask of different request types\n */\nexport const elementTypes = {\n  SCRIPT: 0o1,\n  IMAGE: 0o2,\n  STYLESHEET: 0o4,\n  OBJECT: 0o10,\n  XMLHTTPREQUEST: 0o20,\n  OBJECTSUBREQUEST: 0o40,\n  SUBDOCUMENT: 0o100,\n  DOCUMENT: 0o200,\n  OTHER: 0o400,\n};\n\nconst fingerprintSize = 7;\nlet fingerprintRegex =  /([/?=a-zA-Z0-9.&_-]{7}).*\\$/;\n\n/**\n * Maps element types to type mask.\n */\nexport const elementTypeMaskMap = new Map([\n  ['script', elementTypes.SCRIPT],\n  ['image', elementTypes.IMAGE],\n  ['stylesheet', elementTypes.STYLESHEET],\n  ['object', elementTypes.OBJECT],\n  ['xmlhttprequest', elementTypes.XMLHTTPREQUEST],\n  ['object-subrequest', elementTypes.OBJECTSUBREQUEST],\n  ['subdocument', elementTypes.SUBDOCUMENT],\n  ['document', elementTypes.DOCUMENT],\n  ['other', elementTypes.OTHER]\n]);\n\nconst separatorCharacters = ':?/=^';\n\n/**\n * Parses the domain string using the passed in separator and\n * fills in options.\n */\nexport function parseDomains(input, separator, options) {\n  options.domains = options.domains || [];\n  options.skipDomains = options.skipDomains || [];\n  let domains = input.split(separator);\n  options.domains = options.domains.concat(domains.filter((domain) => domain[0] !== '~'));\n  options.skipDomains = options.skipDomains.concat(domains\n    .filter((domain) => domain[0] === '~')\n    .map((domain) => domain.substring(1)));\n}\n\n/**\n * Parses options from the passed in input string\n */\nexport function parseOptions(input) {\n  let output = {\n    binaryOptions: new Set(),\n  };\n  input.split(',').forEach((option) => {\n    option = option.trim();\n    if (option.startsWith('domain=')) {\n      let domainString = option.split('=')[1].trim();\n      parseDomains(domainString, '|', output);\n    } else {\n      let optionWithoutPrefix = option[0] === '~' ? option.substring(1) : option;\n      if (elementTypeMaskMap.has(optionWithoutPrefix)) {\n        if (option[0] === '~') {\n          output.skipElementTypeMask |= elementTypeMaskMap.get(optionWithoutPrefix);\n        } else {\n          output.elementTypeMask |= elementTypeMaskMap.get(optionWithoutPrefix);\n        }\n      }\n      output.binaryOptions.add(option);\n    }\n  });\n  return output;\n}\n\n/**\n * Finds the first separator character in the input string\n */\nfunction findFirstSeparatorChar(input, startPos) {\n  for (let i = startPos; i < input.length; i++) {\n    if (separatorCharacters.indexOf(input[i]) !== -1) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Parses an HTML filter and modifies the passed in parsedFilterData\n * as necessary.\n *\n * @param input: The entire input string to consider\n * @param index: Index of the first hash\n * @param parsedFilterData: The parsedFilterData object to fill\n */\nexport function parseHTMLFilter(input, index, parsedFilterData) {\n  let domainsStr = input.substring(0, index);\n  parsedFilterData.options = {};\n  if (domainsStr.length > 0) {\n    parseDomains(domainsStr, ',', parsedFilterData.options);\n  }\n\n  // The XOR parsedFilterData.elementHidingException is in case the rule already\n  // was specified as exception handling with a prefixed @@\n  parsedFilterData.isException = !!(input[index + 1] === '@' ^\n    parsedFilterData.isException);\n  if (input[index + 1] === '@') {\n    // Skip passed the first # since @# is 2 chars same as ##\n    index++;\n  }\n  parsedFilterData.htmlRuleSelector = input.substring(index + 2);\n}\n\nexport function parseFilter(input, parsedFilterData, bloomFilter) {\n  input = input.trim();\n\n  // Check for comment or nothing\n  if (input.length === 0) {\n    return false;\n  }\n\n  // Check for comments\n  let beginIndex = 0;\n  if (input[beginIndex] === '[' || input[beginIndex] === '!') {\n    parsedFilterData.isComment = true;\n    return false;\n  }\n\n  // Check for exception instead of filter\n  parsedFilterData.isException = input[beginIndex] === '@' &&\n    input[beginIndex + 1] === '@';\n  if (parsedFilterData.isException) {\n    beginIndex = 2;\n  }\n\n  // Check for element hiding rules\n  let index = input.indexOf('#', beginIndex);\n  if (index !== -1) {\n    if (input[index + 1] === '#' || input[index + 1] === '@') {\n      parseHTMLFilter(input.substring(beginIndex), index - beginIndex, parsedFilterData);\n      // HTML rules cannot be combined with other parsing,\n      // other than @@ exception marking.\n      return true;\n    }\n  }\n\n  // Check for options, regex can have options too so check this before regex\n  index = input.indexOf('$', beginIndex);\n  if (index !== -1) {\n    parsedFilterData.options = parseOptions(input.substring(index + 1));\n    // Get rid of the trailing options for the rest of the parsing\n    input = input.substring(0, index);\n  } else {\n    parsedFilterData.options = {};\n  }\n\n  // Check for a regex\n  parsedFilterData.isRegex = input[beginIndex] === '/' &&\n    input[input.length - 1] === '/' && beginIndex !== input.length - 1;\n  if (parsedFilterData.isRegex) {\n    parsedFilterData.data = input.slice(beginIndex + 1, -1);\n    return true;\n  }\n\n  // Check if there's some kind of anchoring\n  if (input[beginIndex] === '|') {\n    // Check for an anchored domain name\n    if (input[beginIndex + 1] === '|') {\n      parsedFilterData.hostAnchored = true;\n      let indexOfSep = findFirstSeparatorChar(input, beginIndex + 1);\n      if (indexOfSep === -1) {\n        indexOfSep = input.length;\n      }\n      beginIndex += 2;\n      parsedFilterData.host = input.substring(beginIndex, indexOfSep);\n    } else {\n      parsedFilterData.leftAnchored = true;\n      beginIndex++;\n    }\n  }\n  if (input[input.length - 1] === '|') {\n    parsedFilterData.rightAnchored = true;\n    input = input.substring(0, input.length - 1);\n  }\n\n  parsedFilterData.data = input.substring(beginIndex) || '*';\n  if (!parsedFilterData.isException) {\n    if (bloomFilter.exists(getFingerprint(parsedFilterData.data))) {\n      console.log('duplicate found for data: ' + getFingerprint(parsedFilterData.data));\n    }\n    bloomFilter.add(getFingerprint(parsedFilterData.data));\n  }\n  return true;\n}\n\n/**\n * Parses the set of filter rules and fills in parserData\n * @param input filter rules\n * @param parserData out parameter which will be filled\n *   with the filters, exceptionFilters and htmlRuleFilters.\n */\nexport function parse(input, parserData) {\n  parserData.bloomFilter = parserData.bloomFilter || new BloomFilter();\n  parserData.filters = parserData.filters || [];\n  parserData.exceptionFilters = parserData.exceptionFilters || [];\n  parserData.htmlRuleFilters = parserData.htmlRuleFilters || [];\n  let startPos = 0;\n  let endPos = input.length;\n  let newline = '\\n';\n  while (startPos <= input.length) {\n    endPos = input.indexOf(newline, startPos);\n    if (endPos === -1) {\n      newline = '\\r';\n      endPos = input.indexOf(newline, startPos);\n    }\n    if (endPos === -1) {\n      endPos = input.length;\n    }\n    let filter = input.substring(startPos, endPos);\n    let parsedFilterData = {};\n    if (parseFilter(filter, parsedFilterData, parserData.bloomFilter)) {\n      if (parsedFilterData.htmlRuleSelector) {\n        parserData.htmlRuleFilters.push(parsedFilterData);\n      } else if (parsedFilterData.isException) {\n        parserData.exceptionFilters.push(parsedFilterData);\n      } else {\n        parserData.filters.push(parsedFilterData);\n      }\n    }\n    startPos = endPos + 1;\n  }\n}\n\n/**\n * Obtains the domain index of the input filter line\n */\nfunction getDomainIndex(input) {\n  let index = input.indexOf(':');\n  ++index;\n  while (input[index] === '/') {\n    index++;\n  }\n  return index;\n}\n\n/**\n * Similar to str1.indexOf(filter, startingPos) but with\n * extra consideration to some ABP filter rules like ^.\n */\nfunction indexOfFilter(input, filter, startingPos) {\n  if (filter.length > input.length) {\n    return -1;\n  }\n\n  let filterParts = filter.split('^');\n  let index = startingPos;\n  let beginIndex = -1;\n  let prefixedSeparatorChar = false;\n\n  for (let f = 0; f < filterParts.length; f++) {\n    if (filterParts[f] === '') {\n      prefixedSeparatorChar = true;\n      continue;\n    }\n\n    index = input.indexOf(filterParts[f], index);\n    if (index === -1) {\n      return -1;\n    }\n    if (beginIndex === -1) {\n      beginIndex = index;\n    }\n\n    if (prefixedSeparatorChar) {\n      if (separatorCharacters.indexOf(input[index - 1]) === -1) {\n        return -1;\n      }\n    }\n    // If we are in an in between filterPart\n    if (f + 1 < filterParts.length &&\n        // and we have some chars left in the input past the last filter match\n        input.length > index + filterParts[f].length) {\n      if (separatorCharacters.indexOf(input[index + filterParts[f].length]) === -1) {\n        return -1;\n      }\n\n    }\n\n    prefixedSeparatorChar = false;\n  }\n  return beginIndex;\n}\n\nfunction getUrlHost(input) {\n  let domainIndexStart = getDomainIndex(input);\n  let domainIndexEnd = findFirstSeparatorChar(input, domainIndexStart);\n  if (domainIndexEnd === -1) {\n    domainIndexEnd = input.length;\n  }\n  return input.substring(domainIndexStart, domainIndexEnd);\n}\n\nfunction filterDataContainsOption(parsedFilterData, option) {\n  return parsedFilterData.options &&\n    parsedFilterData.options.binaryOptions &&\n    parsedFilterData.options.binaryOptions.has(option);\n}\n\nfunction isThirdPartyHost(baseContextHost, testHost) {\n  if (!testHost.endsWith(baseContextHost)) {\n    return true;\n  }\n\n  let c = testHost[testHost.length - baseContextHost.length - 1];\n  return c !== '.' && c !== undefined;\n}\n\n// Determines if there's a match based on the options, this doesn't\n// mean that the filter rule shoudl be accepted, just that the filter rule\n// should be considered given the current context.\n// By specifying context params, you can filter out the number of rules which are\n// considered.\nfunction matchOptions(parsedFilterData, input, contextParams = {}) {\n  if (contextParams.elementTypeMask !== undefined && parsedFilterData.options) {\n    if (parsedFilterData.options.elementTypeMask !== undefined &&\n        !(parsedFilterData.options.elementTypeMask & contextParams.elementTypeMask)) {\n      return false;\n    } if (parsedFilterData.options.skipElementTypeMask !== undefined &&\n          parsedFilterData.options.skipElementTypeMask & contextParams.elementTypeMask) {\n      return false;\n    }\n  }\n\n  // Domain option check\n  if (contextParams.domain !== undefined && parsedFilterData.options) {\n    if (parsedFilterData.options.domains || parsedFilterData.options.skipDomains) {\n      // Get the domains that should be considered\n      let shouldBlockDomains = parsedFilterData.options.domains.filter((domain) =>\n        !isThirdPartyHost(domain, contextParams.domain));\n\n      let shouldSkipDomains = parsedFilterData.options.skipDomains.filter((domain) =>\n        !isThirdPartyHost(domain, contextParams.domain));\n      // Handle cases like: example.com|~foo.example.com should llow for foo.example.com\n      // But ~example.com|foo.example.com should block for foo.example.com\n      let leftOverBlocking = shouldBlockDomains.filter((shouldBlockDomain) =>\n        shouldSkipDomains.every((shouldSkipDomain) =>\n          isThirdPartyHost(shouldBlockDomain, shouldSkipDomain)));\n      let leftOverSkipping = shouldSkipDomains.filter((shouldSkipDomain) =>\n        shouldBlockDomains.every((shouldBlockDomain) =>\n          isThirdPartyHost(shouldSkipDomain, shouldBlockDomain)));\n\n      // If we have none left over, then we shouldn't consider this a match\n      if (shouldBlockDomains.length === 0 && parsedFilterData.options.domains.length !== 0 ||\n          shouldBlockDomains.length > 0 && leftOverBlocking.length === 0 ||\n          shouldSkipDomains.length > 0 && leftOverSkipping.length > 0) {\n        return false;\n      }\n    }\n  }\n\n  // If we're in the context of third-party site, then consider third-party option checks\n  if (contextParams['third-party'] !== undefined) {\n    // Is the current rule check for third party only?\n    if (filterDataContainsOption(parsedFilterData, 'third-party')) {\n      let inputHost = getUrlHost(input);\n      let inputHostIsThirdParty = isThirdPartyHost(parsedFilterData.host, inputHost);\n      if (inputHostIsThirdParty || !contextParams['third-party']) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Given an individual parsed filter data determines if the input url should block.\n */\nexport function matchesFilter(parsedFilterData, input, contextParams = {}, cachedInputData = {}) {\n  if (!matchOptions(parsedFilterData, input, contextParams)) {\n    return false;\n  }\n\n  // Check for a regex match\n  if (parsedFilterData.isRegex) {\n    if (!parsedFilterData.regex) {\n      parsedFilterData.regex = new RegExp(parsedFilterData.data);\n    }\n    return parsedFilterData.regex.test(input);\n  }\n\n  // Check for both left and right anchored\n  if (parsedFilterData.leftAnchored && parsedFilterData.rightAnchored) {\n    return parsedFilterData.data === input;\n  }\n\n  // Check for right anchored\n  if (parsedFilterData.rightAnchored) {\n    return input.slice(-parsedFilterData.data.length) === parsedFilterData.data;\n  }\n\n  // Check for left anchored\n  if (parsedFilterData.leftAnchored) {\n    return input.substring(0, parsedFilterData.data.length) === parsedFilterData.data;\n  }\n\n  // Check for domain name anchored\n  if (parsedFilterData.hostAnchored) {\n    if (!cachedInputData.currentHost) {\n      cachedInputData.currentHost = getUrlHost(input);\n    }\n\n    return !isThirdPartyHost(parsedFilterData.host, cachedInputData.currentHost) &&\n      indexOfFilter(input, parsedFilterData.data) !== -1;\n  }\n\n  // Wildcard match comparison\n  let parts = parsedFilterData.data.split('*');\n  let index = 0;\n  for (let part of parts) {\n    let newIndex = indexOfFilter(input, part, index);\n    if (newIndex === -1) {\n      return false;\n    }\n    index = newIndex + part.length;\n  }\n\n  return true;\n}\n\nconst maxCached = 100;\n\n/**\n * Using the parserData rules will try to see if the input URL should be blocked or not\n * @param parserData The filter data obtained from a call to parse\n * @param input The input URL\n * @return true if the URL should be blocked\n */\nexport function matches(parserData, input, contextParams = {}, cachedInputData = { }) {\n  if (parserData.bloomFilter) {\n    let cleaned = input.replace(/^https?:\\//, '');\n    if (!parserData.bloomFilter.substringExists(cleaned, fingerprintSize)) {\n      // console.log('early return from bloom filter!');\n      return false;\n    }\n  }\n  // console.log('not early return: ', input);\n  delete cachedInputData.currentHost;\n  cachedInputData.misses = cachedInputData.misses || new Set();\n  cachedInputData.missList = cachedInputData.missList || [];\n  if (cachedInputData.missList.length > maxCached) {\n    cachedInputData.misses.delete(cachedInputData.missList[0]);\n    cachedInputData.missList = cachedInputData.missList.splice(1);\n  }\n  if (cachedInputData.misses.has(input)) {\n    return false;\n  }\n\n  if (parserData.filters.some((parsedFilterData) =>\n    matchesFilter(parsedFilterData, input, contextParams, cachedInputData))) {\n    // Check for exceptions only when there's a match because matches are\n    // rare compared to the volume of checks\n    return !parserData.exceptionFilters.some((parsedFilterData) =>\n      matchesFilter(parsedFilterData, input, contextParams, cachedInputData));\n  }\n\n  cachedInputData.missList.push(input);\n  cachedInputData.misses.add(input);\n  return false;\n}\n\n/**\n * Obtains a fingerprint for the specified filter\n */\nexport function getFingerprint(str) {\n  // TODO: Need to find a way to get better fingerprints\n  let result = fingerprintRegex.exec(str);\n  if (result) {\n    return result[1];\n  }\n  return str.substring(0, fingerprintSize);\n}\n"]}