{"version":3,"sources":["../abp-filter-parser.js"],"names":[],"mappings":"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","file":"abp-filter-parser.js","sourcesContent":["/*\nvar filterOptions = new Set([\n  // Include or exclude JavaScript files.\n  'script',\n  // Include or exclude image files.\n  'image',\n  // Include or exclude stylesheets (CSS files).\n  'stylesheet',\n  // Include or exclude content handled by browser plugins like Flash\n  // or Java.\n  'object',\n  // Include or exclude files loaded by browser plugins.\n  'object-subrequest',\n  // Include or exclude pages loaded within pages (frames).\n  'subdocument',\n  // Used to whitelist the page itself (e.g. @@||example.com^$document).\n  'document',\n  // Used to prevent element rules from applying on a page\n  // (e.g. @@||example.com^$elemhide).\n  'elemhide',\n  // Specify a list of domains, separated by bar lines (|), on which a\n  // filter should be active. A filter may be prevented from being activated\n  // on a domain by preceding the domain name with a tilde (~).\n  'domain=',\n  // Specify whether a filter should be active on third-party or first domains.\n  'third-party',\n]);\n*/\n\nconst separatorCharacters = ':?/=^';\n\n/**\n * Parses the domain string using the passed in separator and\n * fills in options.\n */\nexport function parseDomains(input, separator, options) {\n  options.domains = options.domains || [];\n  options.skipDomains = options.skipDomains || [];\n  let domains = input.split(separator);\n  options.domains = options.domains.concat(domains.filter((domain) => domain[0] !== '~'));\n  options.skipDomains = options.skipDomains.concat(domains\n    .filter((domain) => domain[0] === '~')\n    .map((domain) => domain.substring(1)));\n}\n\n/**\n * Parses options from the passed in input string\n */\nexport function parseOptions(input) {\n  let output = {\n    binaryOptions: new Set(),\n  };\n  input.split(',').forEach((option) => {\n    option = option.trim();\n    if (option.startsWith('domain=')) {\n      let domainString = option.split('=')[1].trim();\n      parseDomains(domainString, '|', output);\n    } else {\n      output.binaryOptions.add(option);\n    }\n  });\n  return output;\n}\n\nfunction findFirstSeparatorChar(input, startPos) {\n  for (let i = startPos; i < input.length; i++) {\n    if (separatorCharacters.indexOf(input[i]) !== -1) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Parses an HTML filter and modifies the passed in parsedFilterData\n * as necessary.\n *\n * @param input: The entire input string to consider\n * @param index: Index of the first hash\n * @param parsedFilterData: The parsedFilterData object to fill\n */\nexport function parseHTMLFilter(input, index, parsedFilterData) {\n  let domainsStr = input.substring(0, index);\n  parsedFilterData.options = {};\n  if (domainsStr.length > 0) {\n    parseDomains(domainsStr, ',', parsedFilterData.options)\n  }\n\n  // The XOR parsedFilterData.elementHidingException is in case the rule already\n  // was specified as exception handling with a prefixed @@\n  parsedFilterData.isException = !!(input[index + 1] === '@' ^\n    parsedFilterData.isException);\n  if (input[index + 1] === '@') {\n    // Skip passed the first # since @# is 2 chars same as ##\n    index++;\n  }\n  parsedFilterData.htmlRuleSelector = input.substring(index + 2);\n}\n\nexport function parseFilter(input, parsedFilterData) {\n  input = input.trim();\n\n  // Check for comment or nothing\n  if (input.length === 0) {\n    return false;\n  }\n\n  // Check for comments\n  let beginIndex = 0;\n  if (input[beginIndex] === '[' || input[beginIndex] === '!') {\n    parsedFilterData.isComment = true;\n    return false;\n  }\n\n  // Check for exception instead of filter\n  parsedFilterData.isException = input[beginIndex] === '@' &&\n    input[beginIndex + 1] === '@';\n  if (parsedFilterData.isException) {\n    beginIndex = 2;\n  }\n\n  // Check for element hiding rules\n  let index = input.indexOf('#', beginIndex);\n  if (index !== -1) {\n    if (input[index + 1] === '#' || input[index + 1] === '@') {\n      parseHTMLFilter(input.substring(beginIndex), index - beginIndex, parsedFilterData);\n      // HTML rules cannot be combined with other parsing,\n      // other than @@ exception marking.\n      return true;\n    }\n  }\n\n  // Check for options, regex can have options too so check this before regex\n  index = input.indexOf('$', beginIndex);\n  if (index !== -1) {\n    parsedFilterData.options = parseOptions(input.substring(index + 1));\n    // Get rid of the trailing options for the rest of the parsing\n    input = input.substring(0, index);\n  } else {\n    parsedFilterData.options = {};\n  }\n\n  // Check for a regex\n  parsedFilterData.isRegex = input[beginIndex] === '/' &&\n    input[input.length - 1] === '/' && beginIndex !== input.length - 1;\n  if (parsedFilterData.isRegex) {\n    parsedFilterData.data = input.slice(beginIndex + 1, -1);\n    return true;\n  }\n\n  // Check if there's some kind of anchoring\n  if (input[beginIndex] === '|') {\n    // Check for an anchored domain name\n    if (input[beginIndex + 1] === '|') {\n      parsedFilterData.hostAnchored = true;\n      let indexOfSep = findFirstSeparatorChar(input, beginIndex + 1);\n      if (indexOfSep === -1) {\n        indexOfSep = input.length;\n      }\n      beginIndex += 2;\n      parsedFilterData.host = input.substring(beginIndex, indexOfSep);\n    } else {\n      parsedFilterData.leftAnchored = true;\n      beginIndex++;\n    }\n  }\n  if (input[input.length - 1] === '|') {\n    parsedFilterData.rightAnchored = true;\n    input = input.substring(0, input.length - 1);\n  }\n\n  parsedFilterData.data = input.substring(beginIndex) || '*';\n  return true;\n}\n\nexport function parse(input, parserData) {\n  parserData.filters = parserData.filters || [];\n  parserData.exceptionFilters = parserData.exceptionFilters  || [];\n  parserData.htmlRuleFilters = parserData.htmlRuleFilters || [];\n  let startPos = 0;\n  let endPos = input.length;\n  let newline = '\\n';\n  while (startPos <= input.length) {\n    endPos = input.indexOf(newline, startPos);\n    if (endPos === -1) {\n      newline = '\\r';\n      endPos = input.indexOf(newline, startPos);\n    }\n    if (endPos === -1) {\n      endPos = input.length;\n    }\n    let filter = input.substring(startPos, endPos);\n    let parsedFilterData = {};\n    if (parseFilter(filter, parsedFilterData)) {\n      if (parsedFilterData.htmlRuleSelector) {\n        parserData.htmlRuleFilters.push(parsedFilterData);\n      } else if (parsedFilterData.isException) {\n        parserData.exceptionFilters.push(parsedFilterData);\n      } else {\n        parserData.filters.push(parsedFilterData);\n      }\n    }\n    startPos = endPos + 1;\n  }\n  return parserData;\n}\n\nfunction getDomainIndex(input) {\n  let index = input.indexOf(':');\n  ++index;\n  while (input[index] === '/') {\n    index++;\n  }\n  return index;\n}\n\n// Similar to str1.indexOf(filter, startingPos) but with\n// extra consideration to some ABP filter rules like ^\nfunction indexOfFilter(input, filter, startingPos) {\n  if (filter.length > input.length) {\n    return -1;\n  }\n\n  let filterParts = filter.split('^');\n  let index = startingPos;\n  let beginIndex = -1;\n  let prefixedSeparatorChar = false;\n\n  for (let f = 0; f < filterParts.length; f++) {\n    if (filterParts[f] === '') {\n      prefixedSeparatorChar = true;\n      continue;\n    }\n\n    index = input.indexOf(filterParts[f], index);\n    if (index === -1) {\n      return -1;\n    }\n    if (beginIndex === -1) {\n      beginIndex = index;\n    }\n\n    if (prefixedSeparatorChar) {\n      if (separatorCharacters.indexOf(input[index - 1]) === -1) {\n        return -1;\n      }\n    }\n    // If we are in an in between filterPart\n    if (f + 1 < filterParts.length &&\n        // and we have some chars left in the input past the last filter match\n        input.length > index + filterParts[f].length) {\n      if (separatorCharacters.indexOf(input[index + filterParts[f].length]) === -1) {\n        return -1;\n      }\n\n    }\n\n    prefixedSeparatorChar = false;\n  }\n  return beginIndex;\n}\n\nfunction getUrlHost(input) {\n  let domainIndexStart = getDomainIndex(input);\n  let domainIndexEnd = findFirstSeparatorChar(input, domainIndexStart);\n  if (domainIndexEnd === -1) {\n    domainIndexEnd = input.length;\n  }\n  return input.substring(domainIndexStart, domainIndexEnd);\n}\n\nfunction filterDataContainsOption(parsedFilterData, option) {\n  return parsedFilterData.options &&\n    parsedFilterData.options.binaryOptions &&\n    parsedFilterData.options.binaryOptions.has(option);\n}\n\nfunction isThirdPartyHost(baseContextHost, testHost) {\n  if (!testHost.endsWith(baseContextHost)) {\n    return true;\n  }\n\n  let prefix = testHost.slice(0, -baseContextHost.length);\n  if (prefix.length > 0 && !prefix.endsWith('.')) {\n    return true;\n  }\n\n  return false;\n}\n\n// Determines if there's a match based on the options, this doesn't\n// mean that the filter rule shoudl be accepted, just that the filter rule\n// should be considered given the current context.\n// By specifying context params, you can filter out the number of rules which are\n// considered.\nfunction matchOptions(parsedFilterData, input, contextParams = {}) {\n  // Lazilly fill this out to be more efficient\n  // Element type checks\n  let elementTypeParams = ['script', 'image', 'stylesheet', 'object',\n   'xmlhttprequest', 'object-subrequest', 'subdocument', 'document', 'other'];\n  for (let elementType of elementTypeParams) {\n    // Check for script context\n    if (contextParams[elementType] !== undefined) {\n      if (!contextParams[elementType] && filterDataContainsOption(parsedFilterData, elementType)) {\n        return false;\n      }\n      else if (contextParams[elementType] && filterDataContainsOption(parsedFilterData, '~' + elementType)) {\n        return false;\n      }\n    }\n  }\n\n  // Domain option check\n  if (contextParams.domain !== undefined && parsedFilterData.options) {\n    if (parsedFilterData.options.domains || parsedFilterData.options.skipDomains) {\n      // Get the domains that should be considered\n      let shouldBlockDomains = parsedFilterData.options.domains.filter((domain) =>\n        !isThirdPartyHost(domain, contextParams.domain));\n\n      let shouldSkipDomains = parsedFilterData.options.skipDomains.filter((domain) =>\n        !isThirdPartyHost(domain, contextParams.domain));\n      // Handle cases like: example.com|~foo.example.com should llow for foo.example.com\n      // But ~example.com|foo.example.com should block for foo.example.com\n      let leftOverBlocking = shouldBlockDomains.filter((shouldBlockDomain) =>\n        shouldSkipDomains.every((shouldSkipDomain) =>\n          isThirdPartyHost(shouldBlockDomain, shouldSkipDomain)));\n      let leftOverSkipping = shouldSkipDomains.filter((shouldSkipDomain) =>\n        shouldBlockDomains.every((shouldBlockDomain) =>\n          isThirdPartyHost(shouldSkipDomain, shouldBlockDomain)));\n\n      // If we have none left over, then we shouldn't consider this a match\n      if (shouldBlockDomains.length === 0 && parsedFilterData.options.domains.length !== 0 ||\n          shouldBlockDomains.length > 0 && leftOverBlocking.length === 0 ||\n          shouldSkipDomains.length > 0 && leftOverSkipping.length > 0) {\n        return false;\n      }\n    }\n  }\n\n  // If we're in the context of third-party site, then consider third-party option checks\n  if (contextParams['third-party'] !== undefined) {\n    // Is the current rule check for third party only?\n    if (filterDataContainsOption(parsedFilterData, 'third-party')) {\n      let inputHost = getUrlHost(input);\n      let inputHostIsThirdParty = isThirdPartyHost(parsedFilterData.host, inputHost);\n      if (inputHostIsThirdParty || !contextParams['third-party']) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nexport function matchesFilter(parsedFilterData, input, contextParams = {}) {\n  if (!matchOptions(parsedFilterData, input, contextParams)) {\n    return false;\n  }\n\n  // Check for a regex match\n  if (parsedFilterData.isRegex) {\n    if (!parsedFilterData.regex) {\n      parsedFilterData.regex = new RegExp(parsedFilterData.data);\n    }\n    return parsedFilterData.regex.test(input);\n  }\n\n  // Check for both left and right anchored\n  if (parsedFilterData.leftAnchored && parsedFilterData.rightAnchored) {\n    return parsedFilterData.data === input;\n  }\n\n  // Check for right anchored\n  if (parsedFilterData.rightAnchored) {\n    return input.slice(-parsedFilterData.data.length) === parsedFilterData.data;\n  }\n\n  // Check for left anchored\n  if (parsedFilterData.leftAnchored) {\n    return input.substring(0, parsedFilterData.data.length) === parsedFilterData.data;\n  }\n\n  // Check for domain name anchored\n  if (parsedFilterData.hostAnchored) {\n    let inputHost = getUrlHost(input);\n    let matchIndex = inputHost.lastIndexOf(parsedFilterData.host);\n    return (matchIndex === 0 || inputHost[matchIndex - 1] === '.') &&\n      inputHost.length <= matchIndex + parsedFilterData.host.length &&\n      indexOfFilter(input, parsedFilterData.data) !== -1;\n  }\n\n  // Wildcard match comparison\n  let parts = parsedFilterData.data.split('*');\n  let index = 0;\n  for (let part of parts) {\n    let newIndex = indexOfFilter(input, part, index);\n    if (newIndex === -1) {\n      return false;\n    }\n    index = newIndex + part.length;\n  }\n\n  return true;\n}\n\nexport function matches(parserData, input, contextParams = {}) {\n  if (parserData.exceptionFilters.some((parsedFilterData) =>\n      matchesFilter(parsedFilterData, input, contextParams))) {\n    return false;\n  }\n\n  return parserData.filters.some((parsedFilterData) =>\n    matchesFilter(parsedFilterData, input, contextParams));\n}\n"]}